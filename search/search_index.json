{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"generated_docs/","title":"Generated docs","text":""},{"location":"generated_docs/#documentation","title":"Documentation","text":""},{"location":"generated_docs/#dokka","title":"Dokka","text":"<p>Dokka Dokka is an API documentation engine for Kotlin.</p> <p>To run the Dokka task in your Gradle project, you need to use the correct task name. The task name can vary based on how you have configured Dokka in your project. Here are the common tasks you might use:</p>"},{"location":"generated_docs/#single-module-project","title":"Single-Module Project","text":"<p>For a single-module project, the most commonly used Dokka task is <code>dokkaHtml</code>:</p> <pre><code>./gradlew dokkaHtml\n</code></pre>"},{"location":"generated_docs/#other-dokka-tasks","title":"Other Dokka Tasks","text":"<p>Depending on your Dokka configuration, there might be other tasks available, such as: - <code>dokkaGfm</code> for generating GitHub Flavored Markdown documentation. - <code>dokkaJekyll</code> for generating Jekyll-compatible documentation.</p>"},{"location":"generated_docs/#finding-available-dokka-tasks","title":"Finding Available Dokka Tasks","text":"<p>To list all available tasks in your project, you can use the following command:</p> <pre><code>./gradlew tasks\n</code></pre>"},{"location":"set_up_instructions/","title":"Instructions","text":"<ul> <li>Setup Instructions</li> </ul>"},{"location":"set_up_instructions/#setup-instructions","title":"Setup Instructions","text":""},{"location":"set_up_instructions/#1-android-studio-settings","title":"1. Android Studio settings","text":"Topic Description Code Style/Formatter Settings &gt; Code Style &gt; Kotlin &gt; Scheme:  Code Style Settings Commit Settings Commit settings Optimize Imports Apply the \"Optimize imports on the fly\" settings in Settings &gt; Editor &gt; General &gt; Auto Import (it can also be done manually with Cmd+Opt+O on Mac/Linux or Ctrl+Alt+O on Windows):  Optimize Imports Manual Formatting Important: When using the terminal or another git management tool, please manually apply formatting to all modified files with Cmd+Opt+L on Mac/Linux or Ctrl+Alt+L on Windows."},{"location":"static_analysis/","title":"Static analysis","text":""},{"location":"static_analysis/#static-analysis","title":"Static Analysis","text":"<p>This project leverages static analysis to ensure that the codebase meets certain standards that can be verified through automation. Two of these libraries are Detekt and Ktlint.</p>"},{"location":"static_analysis/#detekt","title":"Detekt","text":"<p>Detekt is a static analysis tool that checks for code smells. Examples include magic numbers, complicated conditionals, long methods, long parameter lists, and so much more. It is highly configurable, and if you choose to turn off any checks or customize thresholds you can do so in the config file.</p> <p>To run a detekt validation, use the one of the following Gradle commands:</p> <pre><code>./gradlew detekt # Runs over each module synchronously\n</code></pre>"},{"location":"static_analysis/#ktlint","title":"Ktlint","text":"<p>Ktlint is a static analysis tool from Pinterest that prevents bike shedding when it comes to code formatting. It also comes with a Gradle task to automatically format your entire codebase, if it can. The benefit of a tool like this is to ensure everyone on the team will have code formatted the same way, and there's no debating around white spaces, indentation, imports, etc.</p> <p>We use the Kotlinter Ktlint Gradle plugin in this project.</p> <p>The following Gradle commands can be helpful:</p> <pre><code>// Will format the codebase\n./gradlew formatKotlin\n\n// Will check if everything is formatted correctly\n./gradlew lintKotlin\n</code></pre>"},{"location":"code_quality/date_kt/","title":"DateKt","text":""},{"location":"code_quality/date_kt/#about-datekt","title":"<code>About DateKt</code>","text":"<ul> <li>Datekt is a static code analysis tool for kotlin that is capable of identifying</li> <li>Code smells</li> <li>Un-necessary complexity</li> <li>Large class files</li> <li>Poor coding practice</li> <li>And other things that affect code quality</li> </ul>"},{"location":"code_quality/date_kt/#project-location","title":"<code>Project location</code>","text":"<p><code>Documentation</code></p>"},{"location":"code_quality/date_kt/#steps-to-add-the-gradle","title":"<code>Steps to add the Gradle</code>","text":"<ul> <li>Add to project-level build.gradle <pre><code>detekt = { id = \"io.gitlab.arturbosch.detekt\", version.ref = \"detekt\" }\n</code></pre></li> <li>Module level gradle script is added using the script below <pre><code>detekt-formatting = { group = \"io.gitlab.arturbosch.detekt\", name = \"detekt-formatting\", version.ref = \"detekt\" }\n</code></pre></li> </ul>"},{"location":"code_quality/date_kt/#how-to-run-the-plugin","title":"<code>How to run the plugin</code>","text":"<ul> <li>In the terminal run the below command <pre><code>./gradlew detekt\n</code></pre></li> </ul>"},{"location":"code_quality/date_kt/#useful-projects-for-reference","title":"<code>Useful projects for reference</code>","text":"<ul> <li><code>Demo-App-Compose-News</code></li> </ul>"},{"location":"code_quality/date_kt/#steps-to-add-plugin-for-for-multi-module","title":"<code>Steps to add plugin for for multi-module</code>","text":"<ul> <li> <p>Step-1 <code>Define the convention</code> -&gt; <code>Datekt.kt</code> <pre><code>import io.gitlab.arturbosch.detekt.Detekt\nimport io.gitlab.arturbosch.detekt.extensions.DetektExtension\nimport org.gradle.api.Project\nimport org.gradle.kotlin.dsl.configure\nimport org.gradle.kotlin.dsl.dependencies\nimport org.gradle.kotlin.dsl.named\n\ninternal fun Project.configureDetekt(extension: DetektExtension) = extension.apply {\n\n    val projectSource = project.file(project.projectDir)\n    val detektConfigFile = project.files(\"${project.rootDir}/config/detekt/detekt.yml\")\n    val detektBaselineFile = project.file(\"${project.rootDir}/config/detekt/detekt-baseline.xml\")\n    val kotlinFiles = \"**/*.kt\"\n    val detektExclude = listOf(\"**/resources/**\", \"**/build/**\", \"**/test/**\", \"**/androidTest/**\")\n\n    tasks.named&lt;Detekt&gt;(\"detekt\") {\n        val autoFix = project.hasProperty(\"detektAutoFix\")\n        val noBaseline = project.hasProperty(\"noBaseline\")\n\n        description = \"Runs detekt for all modules.\"\n        parallel = true\n        ignoreFailures = false\n        autoCorrect = autoFix\n        buildUponDefaultConfig = true\n        setSource(projectSource)\n        if (!noBaseline) {\n            baseline.set(detektBaselineFile)\n        }\n        config.setFrom(detektConfigFile)\n        include(kotlinFiles)\n        exclude(detektExclude)\n\n        reports {\n            xml.required.set(true)\n            html.required.set(true)\n            txt.required.set(true)\n            sarif.required.set(true)\n            md.required.set(true)\n        }\n    }\n    dependencies {\n        \"detektPlugins\"(libs.findLibrary(\"detekt-formatting\").get())\n    }\n}\n\ninline fun Project.detektGradle(crossinline configure: DetektExtension.() -&gt; Unit) =\n    extensions.configure&lt;DetektExtension&gt; {\n        configure()\n    }\n</code></pre></p> </li> <li> <p>Step-2 <code>Define the plugin that uses the convention</code> -&gt; <code>DetektPlugin.kt</code> <pre><code>import com.istudio.convention.configureDetekt\nimport com.istudio.convention.detektGradle\nimport com.istudio.convention.libs\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\n\nclass DetektPlugin : Plugin&lt;Project&gt; {\n    override fun apply(project: Project) {\n\n        project.run {\n            applyPlugins()\n            detektGradle {\n                configureDetekt(this)\n            }\n        }\n    }\n\n    private fun Project.applyPlugins() {\n        pluginManager.apply {\n            apply(libs.findLibrary(\"detekt-gradlePlugin\").get().get().group.toString())\n        }\n    }\n}\n</code></pre></p> </li> <li>Step-3 Register the plugin in the convention gradle file same as for other plugins.</li> <li>Step-4 Apply the plugin in the modules where it is needed <code>apply(\"runtracer.quality.dateKt\")</code></li> </ul>"},{"location":"code_quality/date_kt/#plugins-that-can-be-added","title":"<code>Plugins that can be added</code>","text":"<ul> <li>DateKt plugin for formatting <pre><code>detekt-formatting = { group = \"io.gitlab.arturbosch.detekt\", name = \"detekt-formatting\", version.ref = \"detekt\" }\n</code></pre></li> <li>Twitter plugin for composables <pre><code>detekt-twitter-compose = { module = \"com.twitter.compose.rules:detekt\", version.ref = \"detekt-twitter-compose\" }\n</code></pre></li> </ul>"},{"location":"documentation/dokka/","title":"Dokka","text":""},{"location":"documentation/dokka/#why-build-logic-module-is-needed","title":"<code>Why build logic module is needed</code>","text":"<ul> <li>We need to have a common place to store the shared config in our app like <code>compile-sdk</code>, <code>build-types</code>, <code>compile-options</code>, <code>etc</code>...</li> <li>This is useful so that we do not need to do this for every single module in the application.</li> </ul>"},{"location":"documentation/dokka/#how-to-achieve-this","title":"<code>How to achieve this</code>","text":"<ul> <li>We can do this in a way called <code>included build</code>.</li> <li>This <code>included module</code> is meant to <code>contain</code> the <code>gradle specific configuration</code>.</li> <li>This module is also meant to be <code>consumed</code> by other <code>gradle-specific</code> files.</li> <li>Here we will just put the configuration that is needed at compile time.</li> <li><code>included build</code> is just adding another gradle project to our project. So we can imagine an entire project with <code>app-modules</code>, and <code>individual-subModules</code> all together become one module, and <code>included build</code> becomes a separate project</li> </ul>"},{"location":"documentation/dokka/#how-to-differentiate-between-normal-kotlin-module-and-gradle-specific-module","title":"<code>How to differentiate between normal kotlin module and gradle specific module</code>","text":"<ul> <li>Say you have created a <code>build-logic</code> module in the application, Your <code>settings.gradle.kts</code> will look like this. <pre><code>pluginManagement {\n    includeBuild(\"build-logic\") //---------------------------------&gt; Add this line\n    repositories {\n        google {\n            content {\n                includeGroupByRegex(\"com\\\\.android.*\")\n                includeGroupByRegex(\"com\\\\.google.*\")\n                includeGroupByRegex(\"androidx.*\")\n            }\n        }\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\nenableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\")\n\nrootProject.name = \"YourApp\"\ninclude(\":app\")\ninclude(\":auth:data\")\n</code></pre></li> </ul>"},{"location":"documentation/dokka/#difference-between-buildsrc-and-buildlogic","title":"<code>Difference between BuildSrc and BuildLogic</code>","text":"<ul> <li><code>BuildSrc</code> --&gt; Here say there are multiple plugins present, when one of them is applied all re-build</li> <li><code>BuildLogic</code> --&gt; Here say there are multiple plugins present, when one of them is applied only that plugin is re-built</li> </ul>"},{"location":"documentation/mk_docs/","title":"<code>Website</code>","text":"<ul> <li><code>Mk-Docs-Official</code></li> <li><code>Material</code></li> </ul>"},{"location":"documentation/mk_docs/#steps","title":"<code>Steps</code>","text":"<ol> <li> <p>Install Python: Run the following command to install Python via Homebrew:    <pre><code>brew install python\n</code></pre></p> </li> <li> <p>Verify Installation: After installation, verify that Python is correctly installed and accessible:    <pre><code>python3 --version\n</code></pre></p> </li> <li> <p>Create a Virtual Environment: Use <code>python3</code> instead of <code>python</code> to create the virtual environment:    <pre><code>python3 -m venv venv\n</code></pre></p> </li> <li> <p>Activate it:    <pre><code>source venv/bin/activate\n</code></pre></p> </li> <li> <p>Check it python is installed:    <pre><code>pip --version\n</code></pre></p> </li> <li> <p>Install mkdocs:    <pre><code>pip install mkdocs-material\n</code></pre></p> </li> <li> <p>Create mkdocs website:    <pre><code>mkdocs new .\n</code></pre></p> </li> <li> <p>Run the website:    <pre><code>mkdocs serve\n</code></pre></p> </li> </ol> <p>Output:    <pre><code>INFO    -  Building documentation...\nINFO    -  Cleaning site directory\nINFO    -  Doc file 'static_analysis.md' contains an absolute link '/config/detekt/detekt.yml', it was left as is.\nINFO    -  Documentation built in 0.03 seconds\nINFO    -  [20:42:24] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO    -  [20:42:24] Serving on http://127.0.0.1:8000/\nINFO    -  [20:42:31] Browser connected: http://127.0.0.1:8000/\n</code></pre></p> <p>Now paste <code>http://127.0.0.1:8000/</code> in your browser and enter</p>"},{"location":"documentation/mk_docs/#install-material","title":"<code>Install Material</code>","text":"<p>Edit the mkdocs.yml <pre><code>site_name: My Docs\ntheme:\n  name: material\n</code></pre></p>"},{"location":"documentation/mk_docs/#useful-source","title":"<code>Useful Source</code>","text":"<ul> <li><code>Tutorial-Documentation With MkDocs Material Theme</code></li> </ul>"},{"location":"foundations/adaptability_to_different_screen_sizes/","title":"<code>Overview</code>","text":"<ul> <li>Various screen displays in Android are becoming more and more important.</li> <li>In the earlier days handling the vast variety of devices with different sizes in Android was very challenging.</li> <li>Now in Android, the area is expanded to more things such as <code>TV</code>, <code>FOLDABLES</code>, <code>DESKTOP</code> and any device imaginable</li> <li>Also the device must adapt and be responsive to things like <code>ORIENTATION</code>, <code>SIZES</code>, and other form factors.</li> </ul>"},{"location":"foundations/adaptability_to_different_screen_sizes/#how-the-screens-are-categorized","title":"<code>How the Screens are Categorized</code>","text":"<p>The window size class categorizes the types as * <code>Compact</code> * <code>Medium</code> * <code>Expanded</code></p>   ![0_TfCECrHpqL_6D4vK](https://github.com/devrath/ComposeAlchemy/assets/1456191/3720f2fc-39c9-4701-8cb9-8d67c075ef24)   <ul> <li><code>Width</code> and <code>Height</code> are calculated separately.</li> <li>At any given time there are two types of device sizes, We refer to them as <code>portrait</code> and <code>landscape</code>.</li> </ul>"},{"location":"foundations/adaptability_to_different_screen_sizes/#importance-of-width","title":"<code>Importance of width</code>","text":"<ul> <li>At any given time we have the ability of vertical-scrolling.</li> <li>The availability of width is more prominent than the height.</li> <li>So, the available width is more important than the height.</li> </ul>"},{"location":"foundations/adaptability_to_different_screen_sizes/#implementation","title":"<code>Implementation</code>","text":""},{"location":"foundations/adaptability_to_different_screen_sizes/#step-1add-the-gradle-lines","title":"<code>Step-1</code>:<code>Add the gradle lines</code>","text":"<pre><code>implementation(platform(\"androidx.compose:compose-bom:2023.08.00\"))\nimplementation(\"androidx.compose.material3:material3-window-size-class\")\n</code></pre>"},{"location":"foundations/adaptability_to_different_screen_sizes/#step-2modifiy-the-set-content-block","title":"<code>Step-2</code>:<code>Modifiy the set content block</code>","text":"<p>The variable needs to be passed in composable so that it can be used throughout the application. <pre><code>setContent {\n   MyTheme {\n       val windowSize = calculateWindowSizeClass(this)\n       // Passthis window-size to your composables\n       OurComposable(windowSize)\n   }\n}     \n</code></pre></p>"},{"location":"foundations/adaptability_to_different_screen_sizes/#using-the-custom-dimension-for-each-screen-that-adapt-to-screen-sizes","title":"<code>Using the custom dimension for each screen that adapt to screen sizes</code>","text":"<p>Define the dimensions <pre><code>@Immutable\nopen class RunTracerDimens {\n    open val margin: Dp = SpacingScale.dp0\n    object SpacingScale {\n        val dp0 = 0.dp\n        val dp1 = 1.dp\n        val dp2 = 2.dp\n        // ---&gt; More as needed\n    }\n}\n\nclass RunTracerDimensMedium : RunTracerDimens() {\n    override val margin: Dp = SpacingScale.dp1\n}\n\nclass RunTracerDimensExpanded : RunTracerDimens() {\n    override val margin: Dp = SpacingScale.dp2\n}\n</code></pre> Define the screen-wise dimensions for adapting screens <pre><code>open class IntroScreenDimen {\n    open val logoBrandNameSpacing: Dp = RunTracerDimens.SpacingScale.dp12\n}\n\nclass IntroScreenDimenMedium : IntroScreenDimen() {\n    override val logoBrandNameSpacing: Dp = RunTracerDimens.SpacingScale.dp14\n}\n\nclass IntroScreenDimenExpanded : IntroScreenDimen() {\n    override val logoBrandNameSpacing: Dp = RunTracerDimens.SpacingScale.dp16\n}\n</code></pre> Define a class that creates object of the above classes <pre><code>class CustomDimens(\n    val app: RunTracerDimens,\n    val introScreenDimen: IntroScreenDimen,\n) {\n    companion object {\n        internal fun createLiskovDimenCompact(): CustomDimens {\n            return CustomDimens(\n                app = RunTracerDimens(),\n                introScreenDimen = IntroScreenDimen()\n            )\n        }\n\n        private fun createLiskovDimenMedium(): CustomDimens {\n            return CustomDimens(\n                app = RunTracerDimensMedium(),\n                introScreenDimen = IntroScreenDimenMedium()\n            )\n        }\n\n        private fun createLiskovDimenExpanded(): CustomDimens {\n            return CustomDimens(\n                app = RunTracerDimensExpanded(),\n                introScreenDimen = IntroScreenDimenMedium()\n            )\n        }\n\n        fun createCustomDimenByWindowSize(windowClassSize: WindowSizeClass?): CustomDimens {\n            return when (windowClassSize?.widthSizeClass) {\n                WindowWidthSizeClass.Compact -&gt; createLiskovDimenCompact()\n                WindowWidthSizeClass.Medium -&gt; createLiskovDimenMedium()\n                WindowWidthSizeClass.Expanded -&gt; createLiskovDimenExpanded()\n                else -&gt; createLiskovDimenCompact()\n            }\n        }\n    }\n}\n\ninternal val LocalCustomDimens =\n    staticCompositionLocalOf { CustomDimens.createLiskovDimenCompact() }\n</code></pre> Define the CustomDimens in your theme class as object to access it throughout the project <pre><code>@Composable\nfun RunTracerTheme(\n    // Flag to determine the dark/light theme\n    isDarkTheme: Boolean = isSystemInDarkTheme(),\n    // Window Size class to determine the screen size\n    windowClassSize: WindowSizeClass? = loadLocalWindowSizeClass(),\n    // Dynamic color is available on Android 12+\n    dynamicColor: Boolean = true,\n    // Parent most top level composable\n    content: @Composable () -&gt; Unit\n) {\n\n}\n\nobject RunTracerTheme {\n    val dimen: CustomDimens\n        @Composable\n        @ReadOnlyComposable\n        get() = LocalCustomDimens.current\n}\n</code></pre> Usage <pre><code>Spacer(modifier = Modifier.height(RunTracerTheme.dimen.introScreenDimen.logoBrandNameSpacing))\n</code></pre></p>"},{"location":"foundations/displaying_all_previews_of_all_screen_sizes/","title":"Displaying all previews of all screen sizes","text":""},{"location":"foundations/displaying_all_previews_of_all_screen_sizes/#usages","title":"<code>Usages</code>","text":"<pre><code>@WindowSizeClassPreviews\n@Composable\nprivate fun IntroScreenPreview() {\n    RunTracerTheme {\n        IntroScreen(\n            onAction = {}\n        )\n    }\n}\n</code></pre>"},{"location":"foundations/displaying_all_previews_of_all_screen_sizes/#codeutilities","title":"<code>CodeUtilities</code>","text":"<pre><code>import android.content.res.Configuration\nimport androidx.compose.ui.tooling.preview.Preview\n\n/**\n * This file contains annotations for various UI previews. These annotations help in\n * testing the UI across different themes (light and dark) and device sizes (compact, medium, expanded).\n * The goal is to ensure a consistent and responsive UI across a wide range of configurations.\n */\n\n//&lt;----------------------- Constants ----------------------------------------&gt;\n\n// Constants for background colors\nprivate const val LightBackgroundColor = 0xFFFFFFFF\nprivate const val DarkBackgroundColor = 0xFF0D0D0D\n\n// Constants for device specifications\nprivate const val CompactDeviceSpec = \"spec:width=360dp,height=1024dp,dpi=480\"\nprivate const val MediumDeviceSpec = \"spec:width=600dp,height=1024dp,dpi=480\"\nprivate const val ExpandedDeviceSpec = \"spec:width=840dp,height=1024dp,dpi=480\"\n\n// Constants for preview names\nprivate const val LightPreviewName = \"Light\"\nprivate const val DarkPreviewName = \"Dark\"\nprivate const val CompactPreviewName = \"Compact\"\nprivate const val CompactDarkPreviewName = \"Compact - Dark\"\nprivate const val MediumPreviewName = \"Medium\"\nprivate const val MediumDarkPreviewName = \"Medium - Dark\"\nprivate const val ExpandedPreviewName = \"Expanded\"\nprivate const val ExpandedDarkPreviewName = \"Expanded - Dark\"\n\n//&lt;----------------------- Constants ----------------------------------------&gt;\n\n//&lt;----------------------- Combined Previews -------------------------------&gt;\n\n/**\n * Combines previews for compact, medium, and expanded device sizes.\n * Used to provide a comprehensive view of the UI across different screen sizes.\n */\n@DeviceCompactPreviews\n@DeviceMediumPreviews\n@DeviceExpandedPreviews\nannotation class WindowSizeClassPreviews\n\n/**\n * Combines theme and window size class previews.\n * Provides a complete set of previews for light and dark themes across various screen sizes.\n */\n@ThemePreviews\n@WindowSizeClassPreviews\nannotation class CompletePreviews\n//&lt;----------------------- Combined Previews --------------------------------&gt;\n\n//&lt;----------------------- Theme Previews -----------------------------------&gt;\n\n/**\n * Defines previews for light and dark themes.\n * Useful for ensuring the UI looks good in both light and dark modes.\n */\n@Preview(\n    name = LightPreviewName,\n    showBackground = true,\n    backgroundColor = LightBackgroundColor\n)\n@Preview(\n    name = DarkPreviewName,\n    showBackground = true,\n    backgroundColor = DarkBackgroundColor,\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n)\nannotation class ThemePreviews\n//&lt;----------------------- Theme Previews -----------------------------------&gt;\n\n//&lt;----------------------- Device Compact Previews --------------------------&gt;\n\n/**\n * Defines previews for compact device sizes.\n * Ensures the UI is responsive and visually appealing on smaller screens (e.g., small phones).\n */\n@Preview(\n    name = CompactPreviewName,\n    showBackground = true,\n    backgroundColor = LightBackgroundColor,\n    device = CompactDeviceSpec\n)\n@Preview(\n    name = CompactDarkPreviewName,\n    showBackground = true,\n    backgroundColor = DarkBackgroundColor,\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n    device = CompactDeviceSpec\n)\nannotation class DeviceCompactPreviews\n//&lt;----------------------- Device Compact Previews --------------------------&gt;\n\n//&lt;----------------------- Device Medium Previews --------------------------&gt;\n\n/**\n * Defines previews for medium device sizes.\n * Useful for testing the UI on medium-sized screens, such as tablets.\n */\n@Preview(\n    name = MediumPreviewName,\n    showBackground = true,\n    backgroundColor = LightBackgroundColor,\n    device = MediumDeviceSpec\n)\n@Preview(\n    name = MediumDarkPreviewName,\n    showBackground = true,\n    backgroundColor = DarkBackgroundColor,\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n    device = MediumDeviceSpec\n)\nannotation class DeviceMediumPreviews\n//&lt;----------------------- Device Medium Previews --------------------------&gt;\n\n//&lt;----------------------- Device Expanded Previews -------------------------&gt;\n\n/**\n * Defines previews for expanded device sizes.\n * Ensures the UI scales well on larger screens, such as large tablets and desktops.\n */\n@Preview(\n    name = ExpandedPreviewName,\n    showBackground = true,\n    backgroundColor = LightBackgroundColor,\n    device = ExpandedDeviceSpec\n)\n@Preview(\n    name = ExpandedDarkPreviewName,\n    showBackground = true,\n    backgroundColor = DarkBackgroundColor,\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n    device = ExpandedDeviceSpec\n)\nannotation class DeviceExpandedPreviews\n//&lt;----------------------- Device Expanded Previews -----------------------&gt;\n</code></pre>"},{"location":"gradle_management/adding_convention_plugins/","title":"Android Application Convention Plugin","text":"<ul> <li>Here we can include Android application-level configuration.</li> </ul>"},{"location":"gradle_management/adding_convention_plugins/#elements-added-here","title":"<code>Elements added here</code>","text":"<ul> <li>Application plugin --&gt; <code>com.android.application</code></li> <li>Kotlin Android --&gt; <code>org.jetbrains.kotlin.android</code></li> <li><code>ApplicationId</code></li> <li><code>TargetSdk</code></li> <li><code>VersionCode</code></li> <li><code>VersionName</code></li> <li><code>Source &amp; target compatibility</code></li> </ul>"},{"location":"gradle_management/adding_convention_plugins/#steps-to-add-the-plugin","title":"<code>Steps to add the plugin</code>","text":"<p><code>Kotlin.kt</code> <pre><code>import com.android.build.api.dsl.AndroidResources\nimport com.android.build.api.dsl.BuildFeatures\nimport com.android.build.api.dsl.BuildType\nimport com.android.build.api.dsl.CommonExtension\nimport com.android.build.api.dsl.DefaultConfig\nimport com.android.build.api.dsl.Installation\nimport com.android.build.api.dsl.ProductFlavor\nimport org.gradle.api.JavaVersion\nimport org.gradle.api.Project\nimport org.gradle.kotlin.dsl.dependencies\nimport org.gradle.kotlin.dsl.withType\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\ninternal fun &lt;BuildFeaturesT : BuildFeatures, BuildTypeT : BuildType, DefaultConfigT : DefaultConfig, ProductFlavorT : ProductFlavor, AndroidResourcesT : AndroidResources, InstallationT : Installation&gt;\n        Project.configureKotlinAndroid(\n    commonExtension: CommonExtension&lt;BuildFeaturesT, BuildTypeT, DefaultConfigT, ProductFlavorT, AndroidResourcesT, InstallationT&gt;\n) {\n    commonExtension.apply {\n        compileSdk = libs.findVersion(\"projectCompileSdkVersion\").get().toString().toInt()\n\n        defaultConfig.minSdk = libs.findVersion(\"projectMinSdkVersion\").get().toString().toInt()\n\n        compileOptions {\n            isCoreLibraryDesugaringEnabled = true\n            sourceCompatibility = JavaVersion.VERSION_11\n            targetCompatibility = JavaVersion.VERSION_11\n        }\n    }\n\n    configureKotlin()\n\n    dependencies {\n        \"coreLibraryDesugaring\"(libs.findLibrary(\"desugar.jdk.libs\").get())\n    }\n}\n\nprivate fun Project.configureKotlin() {\n    tasks.withType&lt;KotlinCompile&gt;().configureEach {\n        kotlinOptions {\n            jvmTarget = JavaVersion.VERSION_11.toString()\n        }\n    }\n}\n</code></pre> <code>ProjectExt.kt</code></p> <p>This is to get access the the versionCatalog in android <pre><code>import org.gradle.api.Project\nimport org.gradle.api.artifacts.VersionCatalog\nimport org.gradle.api.artifacts.VersionCatalogsExtension\nimport org.gradle.kotlin.dsl.getByType\n\nval Project.libs: VersionCatalog\n    get() = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(\"libs\")\n</code></pre></p> <p><code>AndroidApplicationConventionPlugin.kt</code> <pre><code>class AndroidApplicationConventionPlugin : Plugin&lt;Project&gt; {\n\n    override fun apply(target: Project) {\n        target.run {\n            pluginManager.run {\n                apply(\"com.android.application\")\n                apply(\"org.jetbrains.kotlin.android\")\n            }\n            extensions.configure&lt;ApplicationExtension&gt; {\n                defaultConfig {\n                    applicationId = libs.findVersion(\"projectApplicationId\").get().toString()\n                    targetSdk = libs.findVersion(\"projectTargetSdkVersion\").get().toString().toInt()\n\n                    versionCode = libs.findVersion(\"projectVersionCode\").get().toString().toInt()\n                    versionName = libs.findVersion(\"projectVersionName\").get().toString()\n                }\n\n                configureKotlinAndroid(this)\n            }\n        }\n    }\n\n}\n</code></pre></p> <p>build.gradle.kts</p> <p>Register the plugin in the <code>build-logic</code> gradle level <pre><code>gradlePlugin {\n    plugins {\n        register(\"androidApplication\") {\n            id = \"runtracer.android.application\"\n            implementationClass = \"AndroidApplicationConventionPlugin\"\n        }\n    }\n}\n</code></pre></p>"},{"location":"gradle_management/adding_convention_plugins/#buildtype-configuration-plugin","title":"BuildType Configuration Plugin","text":"<p>What we can replace <pre><code>buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n}\n</code></pre></p> <p>Define buildtype file plugin <pre><code>internal fun Project.configureBuildTypes(\n    commonExtension: CommonExtension&lt;*, *, *, *, *,*&gt;,\n    extensionType: ExtensionType,\n    providers: ProviderFactory\n) {\n    commonExtension.run {\n        buildFeatures {\n            buildConfig = true\n        }\n\n        val apiKey = gradleLocalProperties(rootDir,providers).getProperty(\"API_KEY\")\n        when(extensionType) {\n            ExtensionType.APPLICATION -&gt; {\n                extensions.configure&lt;ApplicationExtension&gt; {\n                    buildTypes {\n                        debug {\n                            configureDebugBuildType(apiKey)\n                        }\n                        release {\n                            configureReleaseBuildType(commonExtension, apiKey)\n                        }\n                    }\n                }\n            }\n            ExtensionType.LIBRARY -&gt; {\n                extensions.configure&lt;LibraryExtension&gt; {\n                    buildTypes {\n                        debug {\n                            configureDebugBuildType(apiKey)\n                        }\n                        release {\n                            configureReleaseBuildType(commonExtension, apiKey)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nprivate fun BuildType.configureDebugBuildType(apiKey: String) {\n    buildConfigField(\"String\", \"API_KEY\", \"\\\"$apiKey\\\"\")\n    buildConfigField(\"String\", \"BASE_URL\", \"\\\"https://runique.pl-coding.com:8080\\\"\")\n}\n\nprivate fun BuildType.configureReleaseBuildType(\n    commonExtension: CommonExtension&lt;*, *, *, *, *,*&gt;,\n    apiKey: String\n) {\n    buildConfigField(\"String\", \"API_KEY\", \"\\\"$apiKey\\\"\")\n    buildConfigField(\"String\", \"BASE_URL\", \"\\\"https://runique.pl-coding.com:8080\\\"\")\n\n    isMinifyEnabled = true\n    proguardFiles(\n        commonExtension.getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n        \"proguard-rules.pro\"\n    )\n}\n</code></pre></p> <p>Apply in ApplicationConventionPlugin</p> <pre><code>class AndroidApplicationConventionPlugin : Plugin&lt;Project&gt; {\n\n    override fun apply(target: Project) {\n        target.run {\n            // Other code\n            extensions.configure&lt;ApplicationExtension&gt; {\n                // Other code\n\n                // Add here --&gt;\n                configureBuildTypes(\n                    commonExtension = this,\n                    extensionType = ExtensionType.APPLICATION,\n                    providers = providers\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"gradle_management/adding_convention_plugins/#android-application-compose-convention-plugin","title":"Android Application Compose Convention Plugin","text":""},{"location":"gradle_management/adding_convention_plugins/#compose-blocks-to-replace","title":"<code>Compose blocks to replace</code>","text":"<pre><code> buildFeatures {\n    compose = true\n }\n composeOptions {\n    kotlinCompilerExtensionVersion = \"1.5.1\"\n }\n</code></pre>"},{"location":"gradle_management/adding_convention_plugins/#define-the-convention","title":"<code>Define the convention</code>","text":"<p>AndroidCompose.kt <pre><code>internal fun Project.configureAndroidCompose(\n    commonExtension: CommonExtension&lt;*, *, *, *, *, *&gt;\n) {\n    commonExtension.run {\n        buildFeatures {\n            compose = true\n        }\n\n        composeOptions {\n            kotlinCompilerExtensionVersion = libs\n                .findVersion(\"composeCompiler\")\n                .get()\n                .toString()\n            //kotlinCompilerExtensionVersion = \"1.5.1\"\n        }\n\n        dependencies {\n            val bom = libs.findLibrary(\"androidx.compose.bom\").get()\n            \"implementation\"(platform(bom))\n            \"androidTestImplementation\"(platform(bom))\n            \"debugImplementation\"(platform(bom))\n            //\"debugImplementation\"(libs.findLibrary(\"androidx.compose.ui.tooling.preview\").get())\n        }\n    }\n}\n</code></pre></p>"},{"location":"gradle_management/adding_convention_plugins/#register-the-convention","title":"<code>Register the convention</code>","text":"<p>Add the code block in <code>build-logic</code> build gradle <pre><code>// Other code\n\ngradlePlugin {\n    plugins {\n        // other registrations of convention\n        register(\"androidApplicationCompose\") {\n            id = \"runtracer.android.application.compose\"\n            implementationClass = \"AndroidApplicationComposeConventionPlugin\"\n        }\n    }\n}\n</code></pre></p>"},{"location":"gradle_management/adding_convention_plugins/#android-library-convention-plugin","title":"Android Library Convention Plugin","text":"<ul> <li> <p>We can replace the library module to reflect as below <pre><code>plugins {\n    alias(libs.plugins.runtracer.android.library)\n}\n\nandroid {\n    namespace = \"com.istudio.run.network\"\n}\n\ndependencies {\n    implementation(projects.core.domain)\n    implementation(projects.core.data)\n}\n</code></pre></p> </li> <li> <p>Define <code>AndroidLibraryConventionPlugin</code> <pre><code>class AndroidLibraryConventionPlugin : Plugin&lt;Project&gt; {\n\n    override fun apply(target: Project) {\n        target.run {\n            pluginManager.run {\n                apply(\"com.android.library\")\n                apply(\"org.jetbrains.kotlin.android\")\n            }\n\n            extensions.configure&lt;LibraryExtension&gt; {\n                configureKotlinAndroid(this)\n\n                configureBuildTypes(\n                    commonExtension = this,\n                    extensionType = ExtensionType.LIBRARY,\n                    providers = providers\n                )\n\n                defaultConfig {\n                    testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n                    consumerProguardFiles(\"consumer-rules.pro\")\n                }\n            }\n\n            dependencies {\n                \"testImplementation\"(kotlin(\"test\"))\n            }\n        }\n    }\n}\n</code></pre></p> </li> <li>Register in <code>build-logic</code> level build gradle <pre><code>// Other Code\n\ngradlePlugin {\n    plugins {\n        // Other Code\n        register(\"androidLibrary\") {\n            id = \"runtracer.android.library\"\n            implementationClass = \"AndroidLibraryConventionPlugin\"\n        }\n    }\n}\n</code></pre></li> </ul>"},{"location":"gradle_management/adding_convention_plugins/#android-library-compose-convention-plugin","title":"Android Library Compose Convention Plugin","text":"<ul> <li>Create the plugin below</li> <li>Also apply the library to get inherited <code>apply(\"runtracer.android.library\")</code> <pre><code>class AndroidLibraryComposeConventionPlugin : Plugin&lt;Project&gt; {\n\n    override fun apply(target: Project) {\n        target.run {\n            pluginManager.run {\n                apply(\"runtracer.android.library\")\n            }\n\n            val extension = extensions.getByType&lt;LibraryExtension&gt;()\n            configureAndroidCompose(extension)\n        }\n    }\n}\n</code></pre></li> </ul>"},{"location":"gradle_management/adding_convention_plugins/#android-feature-ui-convention-plugin","title":"Android Feature Ui Convention Plugin","text":"<ul> <li>Create a convention <pre><code>fun DependencyHandlerScope.addUiLayerDependencies(project: Project) {\n    \"implementation\"(project(\":core:presentation:ui\"))\n    \"implementation\"(project(\":core:presentation:designsystem\"))\n\n    \"implementation\"(project.libs.findBundle(\"koin.compose\").get())\n    \"implementation\"(project.libs.findBundle(\"compose\").get())\n    \"debugImplementation\"(project.libs.findBundle(\"compose.debug\").get())\n    \"androidTestImplementation\"(project.libs.findLibrary(\"androidx.compose.ui.test.junit4\").get())\n}\n</code></pre></li> <li>apply it from a single place <pre><code>class AndroidFeatureUiConventionPlugin: Plugin&lt;Project&gt; {\n\n    override fun apply(target: Project) {\n        target.run {\n            pluginManager.run {\n                apply(\"runtracer.android.library.compose\")\n            }\n\n            dependencies {\n                addUiLayerDependencies(target)\n            }\n        }\n    }\n}\n</code></pre></li> <li>Finally register it and apply in feature of presentation modules</li> </ul>"},{"location":"gradle_management/adding_convention_plugins/#android-room-convention-plugin","title":"Android Room Convention Plugin","text":"<ul> <li>Add the plugin below and register it</li> <li>We add this to the database module <pre><code>class AndroidRoomConventionPlugin : Plugin&lt;Project&gt; {\n\n    override fun apply(target: Project) {\n        target.run {\n            pluginManager.run {\n                apply(\"androidx.room\")\n                apply(\"com.google.devtools.ksp\")\n            }\n\n            extensions.configure&lt;RoomExtension&gt; {\n                schemaDirectory(\"$projectDir/schemas\")\n            }\n\n            dependencies {\n                \"implementation\"(libs.findLibrary(\"room.runtime\").get())\n                \"implementation\"(libs.findLibrary(\"room.ktx\").get())\n                \"ksp\"(libs.findLibrary(\"room.compiler\").get())\n            }\n        }\n    }\n}\n</code></pre></li> </ul>"},{"location":"gradle_management/adding_convention_plugins/#jvm-library-convention-plugin","title":"Jvm Library Convention Plugin","text":"<p>Add the JVM library convention plugin, register it and apply to all the domain layers</p> <pre><code>class JvmLibraryConventionPlugin: Plugin&lt;Project&gt; {\n\n    override fun apply(target: Project) {\n        target.run {\n            pluginManager.apply(\"org.jetbrains.kotlin.jvm\")\n            configureKotlinJvm()\n        }\n    }\n}\n</code></pre>"},{"location":"gradle_management/gradle_challenges_multi_module_project/","title":"Gradle challenges","text":"<p>There are 2 main challenges</p>"},{"location":"gradle_management/gradle_challenges_multi_module_project/#dependency-management","title":"<code>Dependency Management</code>","text":"<ul> <li>Say now we have a dependency say <code>material-dependency</code> added app module and also the same dependency is mentioned in 20 other modules.</li> <li>So there comes a scenario where we want to bump up the version. Here it becomes hard to go into each module and increase the version.</li> <li>Someone might miss some and might need to errors that are hard to spot.</li> </ul>"},{"location":"gradle_management/gradle_challenges_multi_module_project/#config-management","title":"<code>Config Management</code>","text":"<ul> <li>Defining a custom gradle plugin for <code>android module</code> and <code>library module</code></li> <li>So it is easy to apply from a single place.</li> <li>This would reduce the duplication of code across the modules and management becomes easier.</li> </ul>"},{"location":"gradle_management/gradle_challenges_multi_module_project/#solution","title":"<code>Solution</code>","text":"<p>Have a single source of truth for dependency management so it is easy to manage the dependencies from one place.</p>"},{"location":"gradle_management/setting_up_build_logic_module/","title":"Setting up build logic module","text":""},{"location":"gradle_management/setting_up_build_logic_module/#documentation","title":"Documentation","text":""},{"location":"gradle_management/setting_up_build_logic_module/#dokka","title":"Dokka","text":"<p>Dokka Dokka is an API documentation engine for Kotlin.</p> <p>To run the Dokka task in your Gradle project, you need to use the correct task name. The task name can vary based on how you have configured Dokka in your project. Here are the common tasks you might use:</p>"},{"location":"gradle_management/setting_up_build_logic_module/#single-module-project","title":"Single-Module Project","text":"<p>For a single-module project, the most commonly used Dokka task is <code>dokkaHtml</code>:</p> <pre><code>./gradlew dokkaHtml\n</code></pre>"},{"location":"gradle_management/setting_up_build_logic_module/#other-dokka-tasks","title":"Other Dokka Tasks","text":"<p>Depending on your Dokka configuration, there might be other tasks available, such as: - <code>dokkaGfm</code> for generating GitHub Flavored Markdown documentation. - <code>dokkaJekyll</code> for generating Jekyll-compatible documentation.</p>"},{"location":"gradle_management/setting_up_build_logic_module/#finding-available-dokka-tasks","title":"Finding Available Dokka Tasks","text":"<p>To list all available tasks in your project, you can use the following command:</p> <pre><code>./gradlew tasks\n</code></pre>"},{"location":"gradle_management/types_of_dependency_handlers/","title":"Types of Dependency handlers","text":"Handler Usage Purpose Scenarios <code>implementation</code> <code>implementation \"dependency\"</code> Adds dependency to compile and runtime classpath. Most common. Use for dependencies needed by the module itself. <code>api</code> <code>api \"dependency\"</code> Adds dependency to compile and runtime classpath and exposes it to dependent modules. Use when the dependency should be exposed to modules that depend on this module. <code>compileOnly</code> <code>compileOnly \"dependency\"</code> Adds dependency to compile classpath only. Use for dependencies needed only at compile time, such as annotations processors. <code>runtimeOnly</code> <code>runtimeOnly \"dependency\"</code> Adds dependency to runtime classpath only. Use for dependencies needed only at runtime, such as logging frameworks. <code>testImplementation</code> <code>testImplementation \"dependency\"</code> Adds dependency to both compile and runtime classpath for the test source set. Use for test dependencies, such as JUnit or Mockito. <code>testCompileOnly</code> <code>testCompileOnly \"dependency\"</code> Adds dependency to compile classpath of test source set only. Use for compile-time dependencies needed only for tests. <code>testRuntimeOnly</code> <code>testRuntimeOnly \"dependency\"</code> Adds dependency to runtime classpath of test source set only. Use for dependencies needed only at test runtime. <code>annotationProcessor</code> <code>annotationProcessor \"dependency\"</code> Adds an annotation processor to the project. Use for dependencies that process annotations at compile time, such as Dagger or Room. <code>kapt</code> <code>kapt \"dependency\"</code> Adds an annotation processor specifically for Kotlin projects. Use when using annotation processors with Kotlin, such as Dagger or Room."},{"location":"gradle_management/what_is_gradle/","title":"What is a gradle","text":"<ul> <li>When we add code in individual files in the app, It does not create an executable application</li> <li>So creating the executable app by organizing the files like a <code>task runner</code> that makes the files run in the right order and with the right input to get the executable app.</li> </ul>"},{"location":"gradle_management/what_is_gradle/#dependency-management","title":"<code>Dependency management</code>","text":"<ul> <li>It has to directly look into all the <code>dependencies</code> mentioned in your project and download it into the project if not downloaded. It looks into the remote containers that we have defined in the project like <code>maven</code>, and <code>j-center</code>.</li> <li>Also if the <code>dependencies</code> you are including contain other dependencies, They also will be downloaded by the gradle.</li> <li>If the module is linked to the project, It has to get the dependencies from the module.</li> </ul>"},{"location":"gradle_management/what_is_gradle/#compilation-management","title":"<code>Compilation management</code>","text":"<ul> <li>Gradle advices all the compilers what to compile.</li> </ul>"},{"location":"gradle_management/what_is_gradle/#runs-gradle-plugins","title":"<code>Runs gradle plugins</code>","text":"<ul> <li>Example if you add a dependency that does the code-generation. That involves a plugin that takes care of code generation. The gradle also manages the plugins by running in the right order.</li> </ul>"},{"location":"gradle_management/what_is_gradle/#build-optimization","title":"<code>Build optimization</code>","text":"<ul> <li>Gradle also has the responsibility of optimizing the build generation by running and following the compilation strategy.</li> <li>It will run the modules in the right order and in parallel as needed.</li> </ul>"},{"location":"gradle_management/what_is_gradle/#build-configuration-management","title":"<code>Build configuration management</code>","text":"<ul> <li>It goes and checks the configs for each grade defined in modules like <code>compile-SDK</code>, <code>namespaces</code> etc ..., Defining the <code>BuildTypes</code> that involves <code>code-obfuscation</code> etc... </li> </ul>"},{"location":"performance/leakcanary/","title":"LeakCanary","text":"<p> LeakCanary is a powerful memory leak detection library for Android, developed by Square. It helps developers detect and diagnose memory leaks in their applications. Here are some key aspects and benefits of using LeakCanary in Android development:</p>"},{"location":"performance/leakcanary/#references","title":"<code>References</code>","text":"<ul> <li><code>Website</code></li> <li><code>Github</code></li> </ul>"},{"location":"performance/leakcanary/#key-aspects-of-leakcanary","title":"Key Aspects of LeakCanary","text":"<ol> <li> <p>Automatic Leak Detection: LeakCanary automatically detects memory leaks in your application. It monitors object lifecycles and alerts you when objects that should be garbage collected are still retained in memory.</p> </li> <li> <p>Easy Integration: Integrating LeakCanary into your Android project is straightforward. You can add it as a dependency in your <code>build.gradle</code> file and initialize it in your application class.</p> </li> <li> <p>Clear Leak Reports: When a leak is detected, LeakCanary provides detailed leak trace reports. These reports help you understand which objects are leaking and why.</p> </li> <li> <p>Heap Analysis: LeakCanary performs heap dumps and analyzes them to find retained objects. It uses the Shark library for efficient heap analysis.</p> </li> <li> <p>UI Notifications: LeakCanary notifies you of detected leaks via notifications. You can tap on these notifications to see detailed leak traces.</p> </li> </ol>"},{"location":"performance/leakcanary/#benefits-of-using-leakcanary","title":"Benefits of Using LeakCanary","text":"<ol> <li> <p>Early Detection: Detecting memory leaks early in the development process helps prevent potential crashes and performance issues in production.</p> </li> <li> <p>Improved App Performance: By identifying and fixing memory leaks, you can improve the overall performance and stability of your application.</p> </li> <li> <p>Reduced Memory Footprint: Fixing memory leaks helps reduce the memory footprint of your application, leading to more efficient memory usage.</p> </li> <li> <p>User Experience: A leak-free app ensures a smoother and more responsive user experience, as there are fewer chances of the app slowing down or crashing due to memory issues.</p> </li> <li> <p>Automated Testing: LeakCanary can be integrated into your automated testing process to catch memory leaks during continuous integration (CI), ensuring that new leaks are detected as soon as they are introduced.</p> </li> </ol>"},{"location":"performance/leakcanary/#how-to-integrate-leakcanary","title":"How to Integrate LeakCanary","text":"<ol> <li>Add Dependency:    <pre><code>dependencies {\n    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.x'\n    // Add the release version if you want to detect leaks in release builds\n    releaseImplementation 'com.squareup.leakcanary:leakcanary-android-release:2.x'\n}\n</code></pre></li> </ol>"},{"location":"performance/leakcanary/#example-leak-report","title":"Example Leak Report","text":"<p>A typical leak report from LeakCanary includes: - Retained Object: The object that is leaking. - References: The chain of references leading to the retained object. - Heap Analysis Details: Information about the heap dump and analysis process.</p> <p>By following the reference chain, you can identify the cause of the leak and fix it. LeakCanary provides suggestions and documentation links to help you understand and resolve common memory leak issues.</p> <p>Using LeakCanary in your Android development process can significantly improve the quality and performance of your applications, making it an essential tool for any Android developer.</p>"},{"location":"project_wide_utilities/creating_error_handling_wrapper/","title":"Creating error handling wrapper","text":"<p>Error.kt <pre><code>interface Error\n</code></pre> Result.kt <pre><code>sealed interface Result&lt;out D, out E: Error&gt; {\n    data class Success&lt;out D&gt;(val data: D): Result&lt;D, Nothing&gt;\n    data class Error&lt;out E: com.istudio.core.domain.util.Error&gt;(val error: E): Result&lt;Nothing, E&gt;\n}\n\ninline fun &lt;T, E: Error, R&gt; Result&lt;T, E&gt;.map(map: (T) -&gt; R): Result&lt;R, E&gt; {\n    return when(this) {\n        is Result.Error -&gt; Result.Error(error)\n        is Result.Success -&gt; Result.Success(map(data))\n    }\n}\n\nfun &lt;T, E: Error&gt; Result&lt;T, E&gt;.asEmptyDataResult(): EmptyDataResult&lt;E&gt; {\n    return map {  }\n}\n\ntypealias EmptyDataResult&lt;E&gt; = Result&lt;Unit, E&gt;\n</code></pre> DataError.kt <pre><code>sealed interface DataError: Error {\n    enum class Network: DataError {\n        REQUEST_TIMEOUT,\n        UNAUTHORIZED,\n        CONFLICT,\n        TOO_MANY_REQUESTS,\n        NO_INTERNET,\n        PAYLOAD_TOO_LARGE,\n        SERVER_ERROR,\n        SERIALIZATION,\n        UNKNOWN\n    }\n\n    enum class Local: DataError {\n        DISK_FULL\n    }\n}\n</code></pre></p>"},{"location":"project_wide_utilities/observing_one_time_events_in_compose/","title":"Observing one time events in Compose","text":"<pre><code>import androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.lifecycle.Lifecycle\nimport androidx.lifecycle.repeatOnLifecycle\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.withContext\n\n@Composable\nfun &lt;T&gt; ObserveAsEvents(\n    flow: Flow&lt;T&gt;,\n    key1: Any? = null,\n    key2: Any? = null,\n    onEvent: (T) -&gt; Unit\n) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    LaunchedEffect(flow, lifecycleOwner.lifecycle, key1, key2) {\n        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n            withContext(Dispatchers.Main.immediate) {\n                flow.collect(onEvent)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"project_wide_utilities/string_resource_management/","title":"String resource management","text":"<p>UiText.kt <pre><code>import android.content.Context\nimport androidx.annotation.StringRes\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\n\nsealed interface UiText {\n    data class DynamicString(val value: String): UiText\n    class StringResource(\n        @StringRes val id: Int,\n        val args: Array&lt;Any&gt; = arrayOf()\n    ): UiText\n\n    @Composable\n    fun asString(): String {\n        return when(this) {\n            is DynamicString -&gt; value\n            is StringResource -&gt; stringResource(id = id, *args)\n        }\n    }\n\n    fun asString(context: Context): String {\n        return when(this) {\n            is DynamicString -&gt; value\n            is StringResource -&gt; context.getString(id, *args)\n        }\n    }\n}\n</code></pre> DataErrorToText.kt <pre><code>fun DataError.asUiText(): UiText {\n    return when(this) {\n        DataError.Local.DISK_FULL -&gt; UiText.StringResource(\n            R.string.error_disk_full\n        )\n        DataError.Network.REQUEST_TIMEOUT -&gt; UiText.StringResource(\n            R.string.error_request_timeout\n        )\n        DataError.Network.TOO_MANY_REQUESTS -&gt; UiText.StringResource(\n            R.string.error_too_many_requests\n        )\n        DataError.Network.NO_INTERNET -&gt; UiText.StringResource(\n            R.string.error_no_internet\n        )\n        DataError.Network.PAYLOAD_TOO_LARGE -&gt; UiText.StringResource(\n            R.string.error_payload_too_large\n        )\n        DataError.Network.SERVER_ERROR -&gt; UiText.StringResource(\n            R.string.error_server_error\n        )\n        DataError.Network.SERIALIZATION -&gt; UiText.StringResource(\n            R.string.error_serialization\n        )\n        else -&gt; UiText.StringResource(R.string.error_unknown)\n    }\n}\n</code></pre></p>"}]}